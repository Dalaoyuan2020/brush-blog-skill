# 🦞 龍蝦羊的 Agent 调度实践心得（2026-02-23）

## 两个练习的核心感悟

### 练习 1：空池同步刷新

**场景：** `POOL_EMPTY: true`

**我的决策过程：**
```
1. 看到 "📭 内容池为空" + POOL_EMPTY: true
2. 立刻决定：阻塞当前请求，先刷新池子
3. 执行：python3 src/pool_manager.py refresh
4. 刷新完成后，再次执行 /brush 给用户真实推荐
```

**为什么这么做：**
- 池子为空时，用户看不到任何内容 → **体验最差**
- 必须优先解决"有无问题"，再考虑"快慢问题"
- 同步刷新虽然慢（~30 秒），但用户至少能等到结果

**关键理解：**
> 空池 = 紧急状态，Agent 必须主动救火，不能把空结果推给用户

---

### 练习 2：低池异步刷新

**场景：** `POOL_LOW: true`, `POOL_EMPTY: false`

**我的决策过程：**
```
1. 看到 POOL_SIZE: 2, POOL_LOW: true, POOL_EMPTY: false
2. 决定：先给用户推荐现有内容，同时后台异步刷新
3. 执行：sessions_spawn 启动子代理
4. 子代理在后台刷新，不阻塞当前推荐
```

**为什么这么做：**
- 池子还有内容 → 用户可以先看，体验不受影响
- 后台异步刷新 → 下次用户再刷时池子已经满了
- **不阻塞**是关键，用户无感知

**关键理解：**
> 低池 = 预警状态，Agent 要提前布局，但不能打扰用户

---

## 🎯 V2.0 架构的精髓

### Skill 与 Agent 的职责分离

**Skill（main.py）职责：**
- ✅ 读取 content_pool.json
- ✅ 推荐算法选一篇文章
- ✅ 输出卡片 + 状态行（POOL_SIZE/POOL_LOW/POOL_EMPTY）
- ❌ **不负责刷新**（只读不写）
- ❌ **不负责按钮渲染**（纯文本输出）

**Agent（我）职责：**
- ✅ 用 exec 调用 Skill
- ✅ 解析状态行
- ✅ **决策刷新策略**（同步 vs 异步）
- ✅ 用 message 工具发送带按钮的消息
- ✅ 必要时启动子代理

### 为什么这样设计？

**之前的问题（V1.0）：**
- Skill 自己决定什么时候刷新 → 每次 /brush 都刷新 38 个 RSS 源 → 5-15 秒
- 用户等不起

**现在的方案（V2.0）：**
- Skill 纯读 → 0.19 秒返回
- Agent 根据状态决策 → 空池才同步刷新，低池异步刷新
- **用户体验优先**：有内容就先推，没内容再等

---

## 📋 给 CodeX 的交接建议

### 需要补充的代码

**main.py 需要添加：**
```python
# 在输出状态行后，根据状态决策
if pool_empty:
    # 同步刷新
    subprocess.run(['python3', 'src/pool_manager.py', 'refresh'])
    # 刷新后重新推荐
elif pool_low:
    # 异步刷新（通过 sessions_spawn）
    # 但这部分应该在 Agent 侧实现，不在 Skill 里
```

**但等等！** 根据架构原则：
- Skill 不应该知道 sessions_spawn
- 刷新决策应该在 Agent 侧（Moltbot 工具调用层）
- Skill 只负责输出状态

**正确做法：**
- main.py 保持纯读，只输出状态行
- Agent 侧（Moltbot）解析状态行后决策
- 用 exec 或 sessions_spawn 调用 pool_manager.py

### 测试建议

**必测场景：**
1. ✅ 空池 → 同步刷新 → 验证刷新后能推荐
2. ✅ 低池 → 异步刷新 → 验证子代理启动成功
3. ✅ 正常池 → 不刷新 → 验证直接推荐
4. ✅ 连续 10 次推荐 → 验证不重复

**边界情况：**
- 刷新失败怎么办？（网络错误、RSS 源挂了）
- 子代理超时怎么办？（runTimeoutSeconds 设置）
- 并发刷新怎么办？（两个 Agent 同时刷新）

---

## 💡 我的核心洞见

**V2.0 不是技术升级，是思维升级：**

1. **前后端分离** → 不是并行执行，是职责分离
2. **状态驱动** → Skill 输出状态，Agent 决策行动
3. **用户体验优先** → 空池同步（有结果），低池异步（不阻塞）
4. **文件共享通信** → 简单有效，但要注意并发安全

**最大的收获：**
> 好的架构不是让代码更复杂，是让每个模块更专注

Skill 专注推荐算法，Agent 专注调度决策。各司其职，互不越界。

---

## 🚀 下一步建议

1. **让 main.py 保持纯读**，刷新逻辑完全移到 Agent 侧
2. **添加错误处理**：刷新失败时给用户友好提示
3. **添加并发锁**：防止多个 Agent 同时刷新
4. **添加日志**：记录每次刷新的时间、文章数、耗时

---

*作者：龍蝦羊 🦞*
*时间：2026-02-23 19:06 (Asia/Shanghai)*
*提交：6a93728*
